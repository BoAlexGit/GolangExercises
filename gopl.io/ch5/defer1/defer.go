// Copyright © 2016 Alan A. A. Donovan & Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/
// Defer1.go
// See page 150 (185).
// АВАРИЙНАЯ СИТУАЦИЯ
// Defer1 demonstrates a deferred call being invoked during a panic.
package main

import (
	"fmt"
)

//!+f
func main() {
	f(3)
}

func f(x int) {
	fmt.Printf("f(%d)\n", x+0/x) // panics if x == 0
	defer fmt.Printf("defer %d\n", x)
	f(x - 1)
}

//!-f

/*При запуске эта программа выводит на стандартный вывод следующее:

//!+stdout
f(3)
f(2)
f(1)
defer 1
defer 2
defer 3
//!-stdout

//!+stderr
panic: runtime error: integer divide by zero
main.f(0)
        src/gopl.io/ch5/defer1/defer.go:14
main.f(1)
        src/gopl.io/ch5/defer1/defer.go:16
main.f(2)
        src/gopl.io/ch5/defer1/defer.go:16

main.f(3)
        src/gopl.io/ch5/defer1/defer.go:16
main.main()
        src/gopl.io/ch5/defer1/defer.go:10
//!-stderr
*/

/**********************************************************
switch s := suit(drawCard());
s {
case "Spades": // ...
case "Hearts": // ...
case "Diamonds": // ...
case "Clubs": // ...
default:
panic(fmt.Sprintf("неверная карта %q", s)) //Джокер?
}
Хорошей практикой является проверка выполнения предусловий функции, но та­
кие проверки могут легко оказаться избыточными. Если только вы не можете предо­
ставить более информативное сообщение об ошибке или обнаружить ошибку зара­
нее, нет смысла в проверке, которую среда выполнения осуществит сама:
func Reset(x *Buffer) {
	if x == nil {
		panic("x is nil") // Нет смысла!
	}
	x.elements = nil
}
Хотя механизм аварийных ситуаций Go напоминает исключения в других языках
программирования, ситуации, в которых он используется, существенно различают­
ся. Так как при этом происходит аварийное завершение программы, этот механизм
обычно используется для грубых ошибок, таких как логическая несогласованность
в программе; прилежные программисты рассматривают любую аварию кода как до­
казательство наличия ошибки в программе. В надежной программе “ожидаемые”
ошибки, т.е. те, которые возникают в результате неправильного ввода, неверной кон­
фигурации или сбоя ввода-вывода, должны быть корректно обработаны; лучше всего
работать с ними с использованием значений e r r o r .
Рассмотрим функцию r e g e x p .C o m p ile , которая компилирует регулярное вы­
ражение в эффективную форму для дальнейшего сопоставления. Она возвращает
e r r o r , если функция вызывается с неправильно сформированным шаблоном, но про­
верка этой ошибки является излишней и обременительной, если вызывающая функ­
ция знает, что определенный вызов не может быть неудачным. В таких случаях раз­
умно, чтобы вызывающая функция обработала ошибку с помощью генерации аварий­
ной ситуации, так как ошибка считается невозможной.
Поскольку большинство регулярных выражений представляют собой литера­
лы в исходном тексте программы, пакет re g e x p предоставляет функцию-оболочку
re g e x p .M u s tC o m p ile , выполняющую такую проверку:
	package regexp
	func Compile(expr string) (*Regexp, error) { /* ... }*/
	/*
func MustCompile(expr string) *Regexp {
		re, err := Compile(expr)
		if err != nil {
		panic(err)
		}
		return re
	}
	Эта функция-оболочка позволяет клиентам удобно инициализировать переменные
	уровня пакета скомпилированным регулярным выражением, как показано ниже:
	var httpSchemeRE=regexp.MustCompile('Ahttps?:') // "http:" или "https:"
	Конечно, функция M u stC o m p ile не должна вызываться с недоверенными входны­
	ми значениями. Префикс M ust является распространенным соглашением именования
	для функций такого рода наподобие te m p l a t e .M u s t в разделе 4.6.
		Когда программа сталкивается с аварийной ситуацией, все отложенные функции
	выполняются в порядке, обратном их появлению в исходном тексте, начиная с функ­
	ции на вершине стека и опускаясь до функции m ain, что демонстрирует приведенная
	ниже программа:
*/